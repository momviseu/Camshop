var J = Object.defineProperty;
var h = Object.getOwnPropertySymbols;
var A = Object.prototype.hasOwnProperty, L = Object.prototype.propertyIsEnumerable;
var K = (e, r, n) => r in e ? J(e, r, { enumerable: !0, configurable: !0, writable: !0, value: n }) : e[r] = n, d = (e, r) => {
  for (var n in r || (r = {}))
    A.call(r, n) && K(e, n, r[n]);
  if (h)
    for (var n of h(r))
      L.call(r, n) && K(e, n, r[n]);
  return e;
};
var w = (e, r) => {
  var n = {};
  for (var s in e)
    A.call(e, s) && r.indexOf(s) < 0 && (n[s] = e[s]);
  if (e != null && h)
    for (var s of h(e))
      r.indexOf(s) < 0 && L.call(e, s) && (n[s] = e[s]);
  return n;
};
import i, { useRef as x, useEffect as C, useState as N, Children as Q, cloneElement as X } from "react";
import o from "prop-types";
import k from "styled-components";
import { useCallbackRef as $ } from "@radix-ui/react-use-callback-ref";
import Y from "@strapi/icons/CarretDown";
import { Typography as F } from "../../Typography/Typography.js";
import { Box as R } from "../../Box/Box.js";
import { Flex as Z } from "../../Flex/Flex.js";
import { Button as V } from "../../Button/Button.js";
import { BaseLink as ee } from "../../BaseLink/BaseLink.js";
import { POPOVER_PLACEMENTS as ne, Popover as te } from "../../Popover/Popover.js";
import { getOptionStyle as q } from "./utils.js";
import { useId as oe } from "../../helpers/useId.js";
import { KeyboardKeys as c } from "../../helpers/keyboardKeys.js";
const re = k.button`
  border: none;
  padding: 0;
  background: transparent;
  cursor: pointer;
  ${q}
`, se = k(ee)`
  text-decoration: none;
  ${q}
`, ie = k.span`
  display: flex;
  align-items: center;
  svg {
    height: 4px;
    width: 6px;
  }
`, ae = k(V)`
  padding: ${({ theme: e }) => `${e.spaces[1]} ${e.spaces[3]}`};
`, W = (b) => {
  var y = b, { as: e, children: r, onClick: n, isFocused: s, isLink: D } = y, I = w(y, ["as", "children", "onClick", "isFocused", "isLink"]);
  const p = x();
  C(() => {
    s && p.current && p.current.focus();
  }, [s]);
  const O = d({
    tabIndex: s ? 0 : -1,
    ref: p,
    role: "menuitem"
  }, I), E = (l) => {
    (l.key === c.SPACE || l.key === c.ENTER) && n();
  };
  return D ? /* @__PURE__ */ i.createElement(se, d({
    as: e
  }, O), /* @__PURE__ */ i.createElement(R, {
    padding: 2
  }, /* @__PURE__ */ i.createElement(F, null, r))) : /* @__PURE__ */ i.createElement(re, d({
    onKeyDown: E,
    onMouseDown: n,
    type: "button"
  }, O), /* @__PURE__ */ i.createElement(R, {
    padding: 2
  }, /* @__PURE__ */ i.createElement(F, null, r)));
};
W.defaultProps = {
  as: void 0,
  onClick() {
  },
  isFocused: !1,
  isLink: !1
};
W.propTypes = {
  as: o.elementType,
  children: o.node.isRequired,
  isFocused: o.bool,
  isLink: o.bool,
  onClick: o.func
};
const P = (O) => {
  var E = O, {
    label: e,
    children: r,
    id: n,
    as: s,
    onOpen: D = () => {
    },
    onClose: I = () => {
    },
    size: b,
    popoverPlacement: y
  } = E, p = w(E, [
    "label",
    "children",
    "id",
    "as",
    "onOpen",
    "onClose",
    "size",
    "popoverPlacement"
  ]);
  const l = x(), v = oe("simplemenu", n), u = x(!1), [m, f] = N(!1), [T, S] = N(0), g = Q.toArray(r), _ = s || (b === "S" ? ae : V);
  C(() => {
    if (["string", "number"].includes(typeof e)) {
      const t = g.findIndex((a) => a.props.children === e);
      t !== -1 && S(t);
    }
  }, [e]);
  const B = $(D), M = $(I);
  C(() => {
    u != null && u.current ? m ? B() : M() : u.current = !0;
  }, [u, m, B, M]), C(() => {
    i.isValidElement(e) && T === -1 && l.current.focus();
  }, [e, T]);
  const z = (t) => {
    m && (t.key === c.ESCAPE && (t.stopPropagation(), f(!1), l.current.focus()), t.key === c.DOWN && S((a) => a === g.length - 1 ? 0 : a + 1), t.key === c.UP && S((a) => a === 0 ? g.length - 1 : a - 1));
  }, j = (t) => {
    (t.key === c.ENTER || t.key === c.SPACE) && f((a) => !a);
  }, U = (t) => {
    t.preventDefault(), t.currentTarget.contains(t.relatedTarget) || f(!1);
  }, G = (t) => {
    t.preventDefault(), f((a) => !a);
  }, H = g.map((t, a) => /* @__PURE__ */ i.createElement(Z, {
    as: "li",
    key: a,
    justifyContent: "center",
    role: "menuitem"
  }, X(t, {
    onClick() {
      t.props.onClick(), f(!1), l.current.focus();
    },
    isFocused: T === a
  })));
  return /* @__PURE__ */ i.createElement("div", {
    onKeyDown: z
  }, /* @__PURE__ */ i.createElement(_, d({
    label: i.isValidElement(e) ? null : e,
    "aria-haspopup": !0,
    "aria-expanded": m,
    "aria-controls": v,
    onKeyDown: j,
    onMouseDown: G,
    ref: l,
    type: "button",
    variant: "ghost",
    endIcon: /* @__PURE__ */ i.createElement(ie, null, /* @__PURE__ */ i.createElement(Y, {
      "aria-hidden": !0
    }))
  }, p), e), m && /* @__PURE__ */ i.createElement(te, {
    onBlur: U,
    placement: y,
    source: l,
    spacing: 4
  }, /* @__PURE__ */ i.createElement(R, {
    role: "menu",
    as: "ul",
    padding: 1,
    id: v
  }, H)));
};
P.defaultProps = {
  as: void 0
};
P.displayName = "SimpleMenu";
P.defaultProps = {
  id: void 0,
  onClose() {
  },
  onOpen() {
  },
  popoverPlacement: "bottom-start",
  size: "M"
};
P.propTypes = {
  as: o.any,
  children: o.oneOfType([o.arrayOf(o.node), o.node]).isRequired,
  id: o.string,
  label: o.oneOfType([o.string, o.number, o.element]).isRequired,
  onClose: o.func,
  onOpen: o.func,
  popoverPlacement: o.oneOf(ne),
  size: o.oneOf(["S", "M"])
};
export {
  W as MenuItem,
  P as SimpleMenu
};
