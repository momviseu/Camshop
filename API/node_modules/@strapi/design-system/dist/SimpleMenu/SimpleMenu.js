var Y = Object.defineProperty;
var g = Object.getOwnPropertySymbols;
var $ = Object.prototype.hasOwnProperty, F = Object.prototype.propertyIsEnumerable;
var N = (e, r, o) => r in e ? Y(e, r, { enumerable: !0, configurable: !0, writable: !0, value: o }) : e[r] = o, y = (e, r) => {
  for (var o in r || (r = {}))
    $.call(r, o) && N(e, o, r[o]);
  if (g)
    for (var o of g(r))
      F.call(r, o) && N(e, o, r[o]);
  return e;
};
var S = (e, r) => {
  var o = {};
  for (var s in e)
    $.call(e, s) && r.indexOf(s) < 0 && (o[s] = e[s]);
  if (e != null && g)
    for (var s of g(e))
      r.indexOf(s) < 0 && F.call(e, s) && (o[s] = e[s]);
  return o;
};
import i, { useRef as w, useEffect as C, useState as V, Children as Z, cloneElement as ee } from "react";
import n from "prop-types";
import v from "styled-components";
import { NavLink as ne } from "react-router-dom";
import { useCallbackRef as q } from "@radix-ui/react-use-callback-ref";
import oe from "@strapi/icons/CarretDown";
import { Typography as L } from "../Typography/Typography.js";
import { Box as x } from "../Box/Box.js";
import { Flex as te } from "../Flex/Flex.js";
import { Button as W } from "../Button/Button.js";
import { POPOVER_PLACEMENTS as re, Popover as se } from "../Popover/Popover.js";
import { getOptionStyle as _ } from "./utils.js";
import { useId as ie } from "../helpers/useId.js";
import { KeyboardKeys as c } from "../helpers/keyboardKeys.js";
const ae = v.button`
  border: none;
  padding: 0;
  background: transparent;
  cursor: pointer;
  ${_}
`, ce = v(ne)`
  text-decoration: none;
  ${_}
`, le = v.span`
  display: flex;
  align-items: center;
  svg {
    height: 4px;
    width: 6px;
  }
`, pe = v(W)`
  padding: ${({ theme: e }) => `${e.spaces[1]} ${e.spaces[3]}`};
`, z = (b) => {
  var E = b, { children: e, onClick: r, to: o, isFocused: s } = E, k = S(E, ["children", "onClick", "to", "isFocused"]);
  const p = w();
  C(() => {
    s && p.current && p.current.focus();
  }, [s]);
  const l = y({
    tabIndex: s ? 0 : -1,
    ref: p,
    role: "menuitem"
  }, k), D = (I) => {
    (I.key === c.SPACE || I.key === c.ENTER) && r();
  };
  return o ? /* @__PURE__ */ i.createElement(ce, y({
    to: o
  }, l), /* @__PURE__ */ i.createElement(x, {
    padding: 2
  }, /* @__PURE__ */ i.createElement(L, null, e))) : /* @__PURE__ */ i.createElement(ae, y({
    onKeyDown: D,
    onMouseDown: r,
    type: "button"
  }, l), /* @__PURE__ */ i.createElement(x, {
    padding: 2
  }, /* @__PURE__ */ i.createElement(L, null, e)));
};
z.defaultProps = {
  as: void 0,
  onClick() {
  },
  isFocused: !1,
  to: void 0
};
z.propTypes = {
  as: n.elementType,
  children: n.node.isRequired,
  isFocused: n.bool,
  onClick: n.func,
  to: n.string
};
const P = (I) => {
  var M = I, {
    label: e,
    children: r,
    id: o,
    as: s,
    onOpen: k = () => {
    },
    onClose: b = () => {
    },
    size: E,
    popoverPlacement: p,
    onReachEnd: l
  } = M, D = S(M, [
    "label",
    "children",
    "id",
    "as",
    "onOpen",
    "onClose",
    "size",
    "popoverPlacement",
    "onReachEnd"
  ]);
  const u = w(), O = ie("simplemenu", o), m = w(!1), [d, f] = V(!1), [R, T] = V(0), h = Z.toArray(r), j = s || (E === "S" ? pe : W), B = !!l && typeof l == "function";
  C(() => {
    if (["string", "number"].includes(typeof e)) {
      const t = h.findIndex((a) => a.props.children === e);
      t !== -1 && T(t);
    }
  }, [e]);
  const K = q(k), A = q(b);
  C(() => {
    m != null && m.current ? d ? K() : A() : m.current = !0;
  }, [m, A, K, d]), C(() => {
    i.isValidElement(e) && R === -1 && u.current.focus();
  }, [e, R]);
  const H = (t) => {
    d && (t.key === c.ESCAPE && (t.stopPropagation(), f(!1), u.current.focus()), t.key === c.DOWN && T((a) => a === h.length - 1 ? 0 : a + 1), t.key === c.UP && T((a) => a === 0 ? h.length - 1 : a - 1));
  }, U = (t) => {
    (t.key === c.ENTER || t.key === c.SPACE) && f((a) => !a);
  }, G = (t) => {
    t.preventDefault(), t.currentTarget.contains(t.relatedTarget) || f(!1);
  }, J = (t) => {
    t.preventDefault(), f((a) => !a);
  }, Q = () => {
    B && l();
  }, X = h.map((t, a) => /* @__PURE__ */ i.createElement(te, {
    as: "li",
    key: a,
    justifyContent: "center",
    role: "menuitem"
  }, ee(t, {
    onClick() {
      t.props.onClick(), f(!1), u.current.focus();
    },
    isFocused: R === a
  })));
  return /* @__PURE__ */ i.createElement("div", {
    onKeyDown: H
  }, /* @__PURE__ */ i.createElement(j, y({
    label: i.isValidElement(e) ? null : e,
    "aria-haspopup": !0,
    "aria-expanded": d,
    "aria-controls": O,
    onKeyDown: U,
    onMouseDown: J,
    ref: u,
    type: "button",
    variant: "ghost",
    endIcon: /* @__PURE__ */ i.createElement(le, null, /* @__PURE__ */ i.createElement(oe, {
      "aria-hidden": !0
    }))
  }, D), e), d && /* @__PURE__ */ i.createElement(se, {
    onBlur: G,
    placement: p,
    source: u,
    onReachEnd: Q,
    intersectionId: B ? `popover-${O}` : void 0,
    spacing: 4
  }, /* @__PURE__ */ i.createElement(x, {
    role: "menu",
    as: "ul",
    padding: 1,
    id: O
  }, X)));
};
P.defaultProps = {
  as: void 0
};
P.displayName = "SimpleMenu";
P.defaultProps = {
  id: void 0,
  onOpen: void 0,
  onClose: void 0,
  onReachEnd: void 0,
  popoverPlacement: "bottom-start",
  size: "M"
};
P.propTypes = {
  as: n.any,
  children: n.oneOfType([n.arrayOf(n.node), n.node]).isRequired,
  id: n.string,
  label: n.oneOfType([n.string, n.number, n.element]).isRequired,
  onClose: n.func,
  onOpen: n.func,
  onReachEnd: n.func,
  popoverPlacement: n.oneOf(re),
  size: n.oneOf(["S", "M"])
};
export {
  z as MenuItem,
  P as SimpleMenu
};
